<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id=".t{5epLSxBAsfN5=NFsr" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id=",lbtZ%sD{{W-JH/l82KX" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum Crumbstatus {" line1="    //% block=&quot;on&quot;" line2="    ON," line3="    //% block=&quot;off&quot;" line4="    OFF" line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="}%TA1fYP,Pi(oN|OlZKL" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum Directions {" line1="    //% block=&quot;up&quot;" line2="    UP, " line3="    //% block=&quot;down&quot; " line4="    DOWN, " line5="    //% block=&quot;left&quot; " line6="    LEFT, " line7="    //% block=&quot;right&quot; " line8="    RIGHT " line9="}" numlines="10"></mutation><next><block type="typescript_statement" id="wd@7XgKX*pX]c+4R}U_s" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace maze{" line1="" line2="" line3="/** maze functions follow below */" line4="" line5="" line6="let showCrumbs = false;" line7="" line8="/**" line9=" * turn showing of breadcrumbs on and off " line10=" * @param status " line11=" */" line12="//% block=&quot;turn breadcrumbs %status&quot;" line13="export function displayCrumbs(status: Crumbstatus) {" line14="    switch (status) {" line15="        case Crumbstatus.ON:" line16="            showCrumbs = true;" line17="            break;" line18="        case Crumbstatus.OFF:" line19="            showCrumbs = false;" line20="            break;" line21="        default:" line22="            // do nothing" line23="    }" line24="}" line25="" line26="// Programmer take care here!" line27="// Make sure that the value defined below, maxDimension," line28="// is used consistently in the function that follows it" line29="" line30="let maxDimension = 15;" line31="" line32="/**" line33=" * start a new game" line34=" * Programmer must ensure that the &quot;.max=&quot; values given below" line35=" * are the same as the maxDimension value defined above" line36=" */" line37="//% rows.min=2 rows.max=15 rows.defl=2" line38="//% cols.min=2 cols.max=15 cols.defl=2" line39="" line40="//% block=&quot;new maze with %rows rows and %cols columns&quot;" line41="export function newMaze(rows: number, cols: number) {" line42="    mazeCOLS = cols;" line43="    mazeROWS = rows;" line44="    startNewGame();" line45="}" line46="" line47="/**" line48=" * return the value of the maxDimension" line49=" */" line50="//% block" line51="export function maximumDimension (): number {" line52="    return maxDimension;" line53="}" line54="" line55="/**" line56=" * initiate motion out of current cell " line57=" * @param direction " line58=" */" line59="//% block=&quot;move %direction&quot;" line60="export function move(direction: Directions) {" line61="    switch (direction) {" line62="        case Directions.UP:" line63="            moveUp(cellRow, cellCol);" line64="            break;" line65="        case Directions.DOWN:" line66="            moveDown(cellRow, cellCol);" line67="            break;" line68="        case Directions.LEFT:" line69="            moveLeft(cellRow, cellCol);" line70="            break;" line71="        case Directions.RIGHT:" line72="            moveRight(cellRow, cellCol);" line73="            break;" line74="        default:" line75="            // do nothing" line76="    }" line77="}" line78="" line79="/******************************************************************" line80=" * facts about the maze " line81=" ******************************************************************/" line82="let maze: Buffer; // to be defined later" line83="let mazeCOLS = 2; // default" line84="let mazeROWS = 2; // default" line85="" line86="// calculates an index number into the maze buffer," line87="// from a pair of row and column numbers" line88="function index (row: number, col: number) {" line89="  return (row * mazeCOLS) + col;" line90="}" line91="" line92="/**" line93=" * constants for defining and analyzing maze contents" line94=" */" line95="const LEFTLINE = 1;" line96="const TOPLINE = 2;" line97="const RIGHTLINE = 4;" line98="const BOTTOMLINE = 8;" line99="const VISITFLAG = 16;" line100="" line101="/*******************************************************************" line102=" * facts about a cell" line103=" *******************************************************************/" line104="let cellRow = 0;" line105="let cellCol = 0;" line106="" line107="/**" line108=" * cellValue returns the value stored" line109=" * at row,col of a maze" line110=" */" line111="function cellValue (row: number, col: number): number {" line112="    return maze.getNumber(NumberFormat.Int8LE, " line113="                    index(row, col)); " line114="}" line115="" line116="/**" line117=" * hasTopBoundary" line118=" * return true if cell at (row, col) has a top boundary" line119=" */" line120="function hasTopBoundary(row: number, col: number): boolean {" line121="    // true if cell is Entrance " line122="    if (isEntrance(row, col)) return true;" line123="    // true if cell is Exit " line124="    if (isExit(row, col)) return true;" line125="    // true if cell defines a TOPLINE " line126="    if ((cellValue(row, col) &amp; TOPLINE) != 0)  return true;" line127="    // otherwise" line128="    return false;" line129="    " line130="}" line131="" line132="/**" line133=" * hasLeftBoundary" line134=" * return true if cell at (row, col) has a left boundary" line135=" */" line136="function hasLeftBoundary(row: number, col: number): boolean {" line137="    // true if cell is Entrance " line138="    if (isEntrance(row, col)) return true;" line139="    // true if cell defines a LEFTLINE " line140="    if ((cellValue(row, col) &amp; LEFTLINE) != 0) return true;" line141="    // otherwise" line142="    return false;" line143="}" line144="" line145="/**" line146=" * hasRightBoundary" line147=" * return true if cell at (row, col) has a right boundary" line148=" */" line149="function hasRightBoundary(row: number, col: number): boolean {" line150="    // true if cell is Exit " line151="    if (isExit(row, col)) return true;" line152="    // true if cell defines a RIGHTLINE " line153="    if ((cellValue(row, col) &amp; RIGHTLINE) != 0) return true;" line154="    // true if the column number to the right is in the maze" line155="    // and the cell in that column on this row defines a LEFTLINE" line156="    if (((col + 1) &lt; mazeCOLS) " line157="        &amp;&amp; ((cellValue(row, col + 1) &amp; LEFTLINE) != 0)) return true;" line158="    // otherwise" line159="    return false;" line160="}" line161="" line162="/**" line163=" * hasBottomBoundary" line164=" * return true if cell at (row, col) has a bottom boundary" line165=" */" line166="function hasBottomBoundary(row: number, col: number): boolean {" line167="    // true if cell is Entrance " line168="    if (isEntrance(row, col)) return true;" line169="    // true if cell is Exit " line170="    if (isExit(row, col)) return true;" line171="    // true if cell defines a BOTTOMLINE " line172="    if ((cellValue(row, col) &amp; BOTTOMLINE) != 0) return true;" line173="    // true if the row number below is in the maze " line174="    // and the cell in this column on that row defines a TOPLINE " line175="    if (((row + 1) &lt; mazeROWS)" line176="        &amp;&amp; ((cellValue(row+1, col) &amp; TOPLINE) != 0)) return true;" line177="    // otherwise" line178="    return false;" line179="}" line180="" line181="function hasBreadcrumb(row: number, col:number): boolean {" line182="    // true if cell's VISITFLAG is turned off " line183="    // I know, that sounds backwards." line184="    // The reason is that we're re-using a flag" line185="    // that was turned on when the maze was being initialized." line186="    // During play, the flag is off for cells that have been visited" line187="    if ((cellValue(row, col) &amp; VISITFLAG) == 0) return true;" line188="    // otherwise" line189="    return false;" line190="}" line191="" line192="function isExit(row: number, col: number): boolean {" line193="    // true if on bottom row and to the right of rightmost cell" line194="    if ((row == mazeROWS - 1) &amp;&amp; (col &gt;= mazeCOLS)) return true;" line195="    // otherwise" line196="    return false;" line197="}" line198="" line199="function isEntrance(row: number, col: number) {" line200="    // true if on row 0 and col is -1" line201="    if ((row == 0) &amp;&amp; (col &lt; 0)) return true;" line202="    // otherwise" line203="    return false;" line204="}" line205="" line206="/*****************************************************************" line207=" * manage movement from one cell to the next " line208=" *****************************************************************/" line209="" line210="// checkCrumb checks for and drops breadcrumb when departing a cell" line211="function checkCrumb(row: number, col: number) {" line212="    if (hasBreadcrumb(row, col)) {" line213="        // the VISITFLAG is already clear; do nothing " line214="    } else {" line215="        // clear the VISITFLAG" line216="        maze.setNumber(NumberFormat.Int8LE, " line217="            index(row, col), " line218="            cellValue(row, col) ^ VISITFLAG);" line219="    }" line220="}" line221="" line222="// moveUp is called from the main loop when pinUp flag is true " line223="function moveUp(row: number, col: number) {" line224="    if (hasTopBoundary(row, col)) {" line225="        flashTopLine();" line226="    } else {" line227="        checkCrumb(row, col);" line228="        arrowsUp();" line229="        cellRow--;" line230="        displayCell(cellRow, cellCol);" line231="    }" line232="}" line233="" line234="// moveLeft is called from the main loop when pinLeft flag is true " line235="function moveLeft(row: number, col: number) {" line236="    if (hasLeftBoundary(row, col)) {" line237="        flashLeftLine();" line238="    } else {" line239="        checkCrumb(row, col);" line240="        arrowsLeft();" line241="        cellCol--;" line242="        displayCell(cellRow, cellCol);" line243="    }" line244="}" line245="" line246="// moveRight is called from the main loop when pinRight flag is true" line247="function moveRight(row: number, col: number) {" line248="    if (hasRightBoundary(row, col)) {" line249="        flashRightLine();" line250="    } else {" line251="        checkCrumb(row, col);" line252="        arrowsRight(); " line253="        cellCol++;" line254="        displayCell(cellRow, cellCol);" line255="    }" line256="}" line257="" line258="//moveDown is called from the main loop when pinDown flag is true " line259="function moveDown(row: number, col: number) {" line260="    if (hasBottomBoundary(row, col)) {" line261="        flashBottomLine();" line262="    } else {" line263="        checkCrumb(row, col);" line264="        arrowsDown(); " line265="        cellRow++;" line266="        displayCell(cellRow, cellCol);" line267="    }" line268="}" line269="" line270="/************************************************************" line271=" * maze motion indicators                                   *" line272=" *   these functions animate a pair of arrowheads           *" line273=" *   moving in the named direction across the LED display   *" line274=" ************************************************************/" line275="let dwellTime = 80; // animation speed, smaller = faster" line276="" line277="function arrowsLeft () {" line278="    basic.clearScreen();" line279="    for (let x = 10; x &gt; 0; x--) {" line280="        shift2ByCol(x-5, x-6);" line281="        shift13ByCol(x-4, x-5);" line282="        shift2ByCol(x-2, x-3);" line283="        shift13ByCol(x-1, x-2);" line284="        basic.pause(dwellTime);" line285="    }" line286="}" line287="" line288="function arrowsUp () {" line289="    basic.clearScreen();" line290="    for (let x2 = 10; x2 &gt; 0; x2--) {" line291="        shift2ByRow(x2-5, x2-6);" line292="        shift13ByRow(x2-4, x2-5);" line293="        shift2ByRow(x2-2, x2-3);" line294="        shift13ByRow(x2-1, x2-2);" line295="        basic.pause(dwellTime);" line296="    }" line297="}" line298="" line299="function arrowsRight () {" line300="    basic.clearScreen();" line301="    for (let x3 = 0; x3 &lt; 10; x3++) {" line302="        shift2ByCol(x3-1, x3);" line303="        shift13ByCol(x3-2, x3-1);" line304="        shift2ByCol(x3-4, x3-3);" line305="        shift13ByCol(x3-5, x3-4);" line306="        basic.pause(dwellTime);" line307="    }" line308="}" line309="" line310="function arrowsDown () {" line311="    basic.clearScreen();" line312="    for (let x4 = 0; x4 &lt; 10; x4++) {" line313="        shift2ByRow(x4-1, x4);" line314="        shift13ByRow(x4-2, x4-1);" line315="        shift2ByRow(x4-4, x4-3);" line316="        shift13ByRow(x4-5, x4-4);" line317="        basic.pause(dwellTime);" line318="    }" line319="}" line320="" line321="/*******************************************************" line322=" * shift2ByRow turns off the LED in column 2 of a row  *" line323=" * and turns the same position on in an adjacent row.  *" line324=" *******************************************************/" line325="function shift2ByRow (prior: number, next: number) {" line326="    // turn off the dot in column 2 of the prior row " line327="    if ((prior &gt;= 0) &amp;&amp; (prior &lt; 5)) led.unplot(2, prior);" line328="    // turn  on the dot in column two of the next row " line329="    if ((next &gt;= 0) &amp;&amp; (next &lt; 5)) led.plot(2, next);" line330="}" line331="" line332="/****************************************************************" line333=" * shift13ByRow turns off the LEDs in columns 1 and 3 of a row  *" line334=" * and turns the same positions on in an adjacent row.          *" line335=" ****************************************************************/" line336="function shift13ByRow (prior: number, next: number) {" line337="    if ((prior &gt;= 0) &amp;&amp; (prior &lt; 5)) {" line338="    // turn off the dots in columns 1 and 3 of the prior row     " line339="        led.unplot(1, prior);" line340="        led.unplot(3, prior);" line341="    }" line342="    if ((next &gt;= 0) &amp;&amp; (next &lt; 5)) {" line343="    // turn on the dots in columns 1 and 3 of the next row " line344="        led.plot(1, next);" line345="        led.plot(3, next);" line346="    }" line347="}" line348="" line349="/**********************************************************" line350=" * shift2ByCol turns off the LED in row 2 of a column     *" line351=" * and turns the same position on in an adjacent column.  *" line352=" **********************************************************/" line353="function shift2ByCol (prior: number, next: number) {" line354="    // turn off the dot in row 2 of the prior column " line355="    if ((prior &gt;= 0) &amp;&amp; (prior &lt; 5)) led.unplot(prior, 2);" line356="    // turn on the dot in row 2 of the next column " line357="    if ((next &gt;= 0) &amp;&amp; (next &lt; 5)) led.plot(next, 2);" line358="}" line359="" line360="/***************************************************************" line361=" * shift13ByCol turns off the LEDs in rows 1 and 3 of a column *" line362=" * and turns the same positions on in an adjacent column.      *" line363=" ***************************************************************/" line364="function shift13ByCol (prior: number, next: number) {" line365="    if ((prior &gt;= 0) &amp;&amp; (prior &lt; 5)) {" line366="    // turn off the dots in rows 1 and 3 of the prior column " line367="        led.unplot(prior, 1);" line368="        led.unplot(prior, 3);" line369="    }" line370="    if ((next &gt;= 0) &amp;&amp; (next &lt; 5)) {" line371="    // turn on the dots in rows 1 and 3 of the next column " line372="        led.plot(next, 1);" line373="        led.plot(next, 3);" line374="    }" line375="}" line376="" line377=" /****************************************************************" line378="  * display functions for the current cell" line379="  ****************************************************************/" line380="function displayCell(row: number, col: number) {" line381="    outlineCell();" line382="    // fill-in applicable edge lines" line383="    if (hasLeftBoundary(row, col)) drawLeftLine();" line384="    if (hasTopBoundary(row, col)) drawTopLine();" line385="    if (hasRightBoundary(row, col)) drawRightLine();" line386="    if (hasBottomBoundary(row, col)) drawBottomLine();" line387="    // show breadcrumbs if flag enabled" line388="    if (showCrumbs &amp;&amp; hasBreadcrumb(row, col)) {" line389="        led.plot(2,2);" line390="    } else {led.unplot(2,2)} // turn crumbs off otherwise " line391="    // don't show a breadcrumb at Entry and Exit locations " line392="    if (isEntrance(row, col)) {" line393="        drawEntryBar();" line394="        led.unplot(2,2);" line395="    }" line396="    if (isExit(row, col)) {" line397="        drawExitBar();" line398="        led.unplot(2,2);" line399="    }" line400="}" line401="" line402="function outlineCell() {" line403="    basic.clearScreen();" line404="    led.plot(0,0);" line405="    led.plot(0,4);" line406="    led.plot(4,0);" line407="    led.plot(4,4);" line408="}" line409="" line410="function drawLeftLine() {" line411="    led.plot(0,1);" line412="    led.plot(0,2);" line413="    led.plot(0,3);" line414="}" line415="" line416="function drawRightLine() {" line417="    led.plot(4,1);" line418="    led.plot(4,2);" line419="    led.plot(4,3);" line420="}" line421="" line422="function drawTopLine() {" line423="    led.plot(1,0);" line424="    led.plot(2,0);" line425="    led.plot(3,0);" line426="}" line427="" line428="function drawBottomLine() {" line429="    led.plot(1,4);" line430="    led.plot(2,4);" line431="    led.plot(3,4);" line432="}" line433="" line434="function drawEntryBar() {" line435="    led.plot(1,1);" line436="    led.plot(1,2);" line437="    led.plot(1,3);" line438="}" line439="" line440="function drawExitBar() {" line441="    led.plot(3,1);" line442="    led.plot(3,2);" line443="    led.plot(3,3);" line444="}" line445="" line446="// the following functions flash a boundary line" line447="" line448="function flashLeftLine() {" line449="    for (let count = 0; count &lt; 6; count++) {" line450="        led.toggle(0,0);" line451="        led.toggle(0,1);" line452="        led.toggle(0,2);" line453="        led.toggle(0,3);" line454="        led.toggle(0,4);" line455="        basic.pause(100);" line456="    }" line457="}" line458="" line459="function flashTopLine() {" line460="    for (let count2 = 0; count2 &lt; 6; count2++) {" line461="        led.toggle(0,0);" line462="        led.toggle(1,0);" line463="        led.toggle(2,0);" line464="        led.toggle(3,0);" line465="        led.toggle(4,0);" line466="        basic.pause(100);" line467="    }" line468="}" line469="" line470="function flashRightLine() {" line471="    for (let count3 = 0; count3 &lt; 6; count3++) {" line472="        led.toggle(4,0);" line473="        led.toggle(4,1);" line474="        led.toggle(4,2);" line475="        led.toggle(4,3);" line476="        led.toggle(4,4);" line477="        basic.pause(100);" line478="    }" line479="}" line480="" line481="function flashBottomLine() {" line482="    for (let count4 = 0; count4 &lt; 6; count4++) {" line483="        led.toggle(0,4);" line484="        led.toggle(1,4);" line485="        led.toggle(2,4);" line486="        led.toggle(3,4);" line487="        led.toggle(4,4);" line488="        basic.pause(100);" line489="    }" line490="}" line491="" line492="/***************************************************************" line493=" * The following relate to creating a new maze " line494=" * having mazeROWS rows and mazeCOLS columns " line495=" ***************************************************************/" line496="    // random-number generator returns 0 or 1" line497="    // used below in makeMaze() function" line498="    function rand01() {" line499="      let randByte = 0;" line500="    &#9;if (Math.random() &gt;= 0.5) {" line501="    &#9;&#9;randByte = 1;" line502="&#9;    }" line503="      return randByte;" line504="    }" line505="" line506="function startNewGame() {" line507="    // turn off breadcrumb display " line508="    showCrumbs = false;" line509="    // turn off the breadcrumb status LED " line510="    pins.digitalWritePin(DigitalPin.P16, 0);" line511="    // create a new maze" line512="    makeMaze();" line513="    // place the player at the game entrance" line514="    cellRow = 0;" line515="    cellCol = -1;" line516="    // display the entrance" line517="    displayCell(cellRow, cellCol);" line518="}" line519="" line520="/****************************************************************" line521=" * makeMaze&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*" line522=" * Applies the Aldus-Broder algorithm for discovering&#9;&#9;&#9;*" line523=" * uniform spanning trees within a rectangular matrix.  &#9;&#9;*" line524=" * See discussion in the following web pages:&#9;&#9;&#9;&#9;&#9;*" line525=" * http://weblog.jamisbuck.org/2011/1/17/...&#9;&#9;&#9;&#9;&#9;*" line526=" *      ...maze-generation-aldous-broder-algorithm&#9;&#9;&#9;&#9;*" line527=" * http://people.cs.ksu.edu/~ashley78/wiki.ashleycoleman.me/... *" line528=" *      ...index.php/Aldous-Broder_Algorithm.html&#9;&#9;&#9;&#9;*" line529=" *&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;*" line530=" * David Sparks Original c code written October 2019&#9;&#9;&#9;*" line531=" * Adapted January 2021 for MakeCode to run on a micro:bit &#9;&#9;*" line532=" ****************************************************************/" line533="function makeMaze() {" line534="    // maze-creation variables" line535="    /********************************************************************************* " line536="     * GENERAL INFORMATION ABOUT THE MAZE DATA STRUCTURE" line537="     * The maze array is stored in a buffer of raw bytes, " line538="     * one byte per maze cell, in an effort to conserve RAM." line539="     * The one byte operates as a bitfield representing six distinct cell properties." line540="     * The buffer object is declared above with the name, maze." line541="     * It gets defined below, in the following sections." line542="     * The buffer's values are exposed by getter and setter methods," line543="     * getNumber() and setNumber()." line544="     * The methods take a NumberFormat object as an argument." line545="     * We use the NumberFormat.Int8LE, representing 8-bit integers." line546="     * The methods also take an offset into the buffer." line547="     * Example, 10 rows of 5 cols gives 10 x 5 = a 50-byte buffer." line548="     * Its values may be accessed with an offset value of 0 through 49." line549="     * Translating offset from a row, column context requires calculation." line550="     * offset = (&lt;row number&gt; * &lt;number of columns&gt;) + &lt;column number&gt;." line551="     * This is handled by the index(row, col) function defined above." line552="     * Example of getting a value at row, col:" line553="     * value = maze.getNumber(NumberFormat.Int8LE, index(row, col))" line554="     * This code body gives a second way to get a cell's value, " line555="     * namely the cellValue(row, col) function defined above." line556="     *********************************************************************************/" line557="" line558="    // Calculate number of cells from mazeROWS and mazeCOLS" line559="    // as those values stand at the time this function gets run." line560="    // Note: 2 x 2 is the startup default but user may change." line561="    let unVisited = mazeROWS*mazeCOLS; " line562="  &#9;// initialize maze buffer" line563="    maze = pins.createBuffer(unVisited);" line564="    // Set each and all cells to have a top line and a left line" line565="    maze.fill(TOPLINE + LEFTLINE);" line566="" line567="    /*********************************************************************************" line568="     * I want to keep the program in row,col context as much as possible." line569="     * Because it is easier for me, a human, " line570="     * to read and understand the code that way." line571="     * The arrays for origin, destination, and motion" line572="     * are regular Typescript numbers because it's easiest that way." line573="     *********************************************************************************/" line574="    let origin = [0,0];  // [row, col]" line575="    let destination = [0,0];" line576="    let motion = [0,0];" line577="    let row = 0;" line578="    let col = 0;" line579="    /****************************************************" line580="    * The following section modifies the initial values" line581="    * of certain cells in the buffer" line582="    ****************************************************/" line583="" line584="  &#9;// turn off the left line on the upper-left cell" line585="  &#9;maze.setNumber(NumberFormat.Int8LE, 0, " line586="      maze.getNumber(NumberFormat.Int8LE, 0) ^ LEFTLINE);" line587="  " line588="  &#9;// give bottom row of cells a bottom line" line589="  &#9;for (col = 0; col &lt; mazeCOLS; col++) {" line590="      /*********************************************************" line591="       * (ROWS - 1) gives the row number of the bottom row" line592="       * when counting from zero, as Javascript does for arrays." line593="       *********************************************************/" line594="  &#9;&#9;maze.setNumber(NumberFormat.Int8LE, index((mazeROWS - 1), col)," line595="          cellValue((mazeROWS - 1), col) + BOTTOMLINE);" line596="  &#9;}" line597="      " line598="  &#9;// Give the right-most column of cells a right side line" line599="  &#9;// except for the cell on the bottom row." line600="  &#9;for (row = 0; row &lt; mazeROWS - 1; row++) {" line601="      /**********************************************************" line602="       * COLS - 1 is the offset for the right-most cell of a row" line603="       **********************************************************/" line604="        maze.setNumber(NumberFormat.Int8LE, index(row, (mazeCOLS - 1))," line605="          cellValue(row, (mazeCOLS - 1)) + RIGHTLINE);" line606="  &#9;}" line607="    /******************************************************************" line608="    * The next section provides the method for navigating the buffer  " line609="    ******************************************************************/" line610="" line611="    /**************************************************************" line612="     * The following steps for determing location within the maze" line613="     * take place in row, col context. This is OK because" line614="     * code calculates index into the cell array" line615="     * at the moment of accessing the array." line616="     **************************************************************/" line617="      " line618="    // select random starting cell" line619="  &#9;origin[0] = Math.trunc(Math.random() * mazeROWS);" line620="  &#9;origin[1] = Math.trunc(Math.random() * mazeCOLS);" line621="  &#9;// mark it as visited" line622="    // origin[0] is a row number, and origin[1] is a col number" line623="    maze.setNumber(NumberFormat.Int8LE, index(origin[0], origin[1])," line624="       cellValue(origin[0], origin[1]) ^ VISITFLAG);" line625="  &#9;// decrement count of unvisited cells" line626="  &#9;unVisited -= 1;" line627="/******************************* */" line628="  &#9;// visit all the other cells" line629="  &#9;while (unVisited &gt; 0) {" line630="" line631="  &#9;&#9;// find a valid destination" line632="  &#9;&#9;do {" line633="  &#9;&#9;&#9;if (rand01() == 0) {" line634="  &#9;&#9;&#9;&#9;motion[0] = (rand01() * 2) - 1;" line635="  &#9;&#9;&#9;&#9;motion[1] = 0;" line636="  &#9;&#9;&#9;} else {" line637="  &#9;&#9;&#9;&#9;motion[0] = 0;" line638="  &#9;&#9;&#9;&#9;motion[1] = (rand01() * 2) - 1;" line639="  &#9;&#9;&#9;}" line640="  &#9;&#9;&#9;destination[0] = origin[0] + motion[0];" line641="  &#9;&#9;&#9;destination[1] = origin[1] + motion[1];" line642="  &#9;&#9;} while (" line643="  &#9;&#9;&#9;destination[0] &lt; 0" line644="  &#9;&#9;&#9;|| destination[0] &gt;= mazeROWS" line645="  &#9;&#9;&#9;|| destination[1] &lt; 0" line646="  &#9;&#9;&#9;|| destination[1] &gt;= mazeCOLS" line647="  &#9;&#9;);      " line648="" line649="  &#9;&#9;// test destination for visited" line650="        if ((cellValue( destination[0], destination[1] ) &amp; VISITFLAG) == 0) {" line651="            // this cell has not been visited, " line652="            // therefore, continue the path into it from the origin cell" line653="" line654="            // mark the destination cell as visited" line655="            maze.setNumber(NumberFormat.Int8LE," line656="                index(destination[0], destination[1])," line657="                cellValue( destination[0], destination[1] ) ^ VISITFLAG);" line658="" line659="            // decrement unVisited counter" line660="            unVisited--;" line661="/******************************** */" line662="" line663="/****************************************************************** " line664=" * Modify the values of cells in the buffer to clear cell boundary " line665=" * between the origin and the destination cells  " line666=" ******************************************************************/" line667="" line668="  &#9;&#9;&#9;if (motion[0] &lt; 0) {" line669="                // moving up one row, clear top line of origin cell   " line670="  &#9;&#9;&#9;&#9;maze.setNumber(NumberFormat.Int8LE, " line671="                  index(origin[0], origin[1])," line672="                    cellValue( origin[0], origin[1] ) ^ TOPLINE);" line673="  &#9;&#9;&#9;}" line674="  &#9;&#9;&#9;if (motion[0] &gt; 0) {" line675="                // moving down one row, clear top line of destination cell " line676="                maze.setNumber(NumberFormat.Int8LE, " line677="                    index(destination[0], destination[1])," line678="                    cellValue( destination[0], destination[1] ) ^ TOPLINE);" line679="//                    maze.getNumber(NumberFormat.Int8LE, " line680="//                        index(destination[0], destination[1])) ^ TOPLINE);" line681="  &#9;&#9;&#9;}" line682="  &#9;&#9;&#9;if (motion[1] &lt; 0) {" line683="                // moving left one column, clear left line of origin cell " line684="                maze.setNumber(NumberFormat.Int8LE, " line685="                    index(origin[0], origin[1]), " line686="                    cellValue( origin[0], origin[1] ) ^ LEFTLINE);" line687="  &#9;&#9;&#9;}" line688="  &#9;&#9;&#9;if (motion[1] &gt; 0) {" line689="                // moving right one column, clear left line of destination cell " line690="                maze.setNumber(NumberFormat.Int8LE, " line691="                    index(destination[0], destination[1]), " line692="                    cellValue( destination[0], destination[1] ) ^ LEFTLINE);" line693="  &#9;&#9;&#9;}" line694="        } // End of if cell not visited " line695="  &#9;&#9;// Destination becomes the new origin" line696="  &#9;&#9;origin[0] = destination[0];" line697="  &#9;&#9;origin[1] = destination[1];" line698="    } // End of while (unVisited) loop" line699="    // All cells have been visited. Maze is completely defined." line700="}" line701="    " line702="}" numlines="703"></mutation></block></next></block></next></block></statement></block></xml>